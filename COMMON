#!/bin/sh ## not executable, just for syntax highlighting

unset LD_PRELOAD

script="$(realpath "$0")"
dir="$(dirname "$script")"
progname="$(basename "$0")"
realprog="$(basename "$script")"

busybox="$dir/busybox"
termux_root="/data/data/com.termux/files"
tmpdir="$termux_root/usr/tmp"
cgroupfs="/sys/fs/cgroup"
cgroup_master="$cgroupfs/tcm"
cgroup_prefix="$cgroup_master/_"
config_dir="$dir/config"
ns_dir="$dir/ns"
config_loaded=0
lock_fd=114
lock_file="$dir/COMMON"
lock_open=0
lock_get=0

container_mount()(:)

load_config()
{
	case "$1" in
	*/*|*"'"*) error "invalid container name";;
	esac
	cont_name="$1"
	cgroup_dir="$cgroup_prefix$cont_name"
	local container_description="(no description)"
	unset container_root
	. "$config_dir/$cont_name.conf"
	cont_root="$container_root"
	cont_desc="$container_description"
	[ -d "$cont_root" ] || mkdir -o "$cont_root"
	config_loaded=1
}

need_config() # use brackets to correctly exit
{
	[ "$config_loaded" = 1 ] || error "no config loaded"
}

error() # don't use () because exit doesn't work in a subshell
{
	echo "$progname: $1" >&2; exit "${2-1}"
}

countdown() ### ( time/s:, [msg], [finmsg] )
{
	local time="$1" msg="${2-}" finmsg="${3-}"
	while [ "$time" -gt 0 ]
	do	echo "$msg$time"
		sleep 1
		time="$((time - 1))"
	done
	[ "$finmsg" = "" ] || echo "$finmsg"
}

check_busybox()
{
	[ -f "$busybox" ] || error "Please copy magisk busybox to repo root"
	[ -x "$busybox" ] || chmod +x "$busybox"
	"$busybox" sh -ec "set -o standalone" || error "busybox version unsupported"
}

lock()
{
	local oper="$1"
	case "$oper" in
	open)	[ "$lock_open" != 1 ] || return 0
		eval "exec $lock_fd<>"'"$lock_file"'
		lock_open=1;;
	get)	[ "$lock_get" != 1 ] || return 0
		flock -nE 41 "$lock_fd" || \
		{
			[ "$?" = 41 ] || error "failed to get lock"
			echo "lock is get by another process, waiting..."
		}
		flock "$lock_fd" || error "failed to get lock"
		lock_get=1;;
	release):
		[ "$lock_get" = 1 ] || return 0
		flock -u "$lock_fd"
		lock_get=0;;
	close)	[ "$lock_open" = 1 ] || return 0
		eval "exec $lock_fd<&-"
		lock_get=0 lock_open=0;;
	esac
}

execute()
{
	[ "$lock_get" != 1 ] || lock close
	exec "$@"
}

## end of defs

[ "$(id -u)" = 0 ] || error "need root privilege"
check_busybox
(set -o standalone 2>/dev/null) || execute "$busybox" sh -eu "$script" "$@"

lock open
lock get

ns()
{
need_config
	local oper="$1"; shift
	local mntns="$ns_dir/$cont_name.mnt"
	case "$oper" in
	open)	[ -d "$ns_dir" ] || mkdir "$ns_dir"
		[ -f "$mntns" ] || \
		 touch "$mntns"
		[ "$(stat -fc "%T" "$mntns")" = "nsfs" ] || \
		 unshare --mount="$mntns" true;;
	drop)	while [ "$(stat -fc "%T" "$mntns")" = "nsfs" ]
		do umount "$mntns" 2>/dev/null
		done
		fs remove_switched_root_flag;;
	run|exec):
		local prog="$1"; shift
		local exec=
		ns open
		[ "$oper" != "exec" ] || exec=execute
		$exec nsenter -m"$mntns" -- "$prog" "$@";;
	*) error "unknown ns operation '$oper'";;
	esac
}

fs()
{
need_config
	local oper="$1"; shift
	case "$oper" in
	is_switched_root) cgroup is_marked switched_root;;
	remove_switched_root_flag) cgroup unmark switched_root;;
	switch_root):
		[ "$(fs is_switched_root)" = 0 ] || return 0
		cgroup mark switched_root
		ns run "$busybox" sh -euo standalone "$dir/switch_root_helper" "$cont_root";;
	bind)	local src="$1"; dst="$2"; shift 2
		[ "$(fs is_switched_root)" = 0 ] || return 0
		[ -d "$cont_root/$dst" ] || mkdir -p "$cont_root/$dst"
		ns run mount "$@" -R "$src" "$cont_root/$dst";;
	esac
}

macro()
{
need_config
	local oper="$1"; shift
	case "$oper" in
	mount_base):
		## suid root
		fs bind "$cont_root" "/" -o suid,dev
		## linux runtime
		for i in /proc /sys /dev
		do fs bind "$i" "$i"
		done;;
	mount_android_runtime):
		for i in /apex/com.android.runtime /linkerconfig /system
		do fs bind "$i" "$i"
		done;;
	esac
}

mount_fs()
{
need_config
	macro mount_base
	container_mount
}

cgroup()
{
need_config
	local oper="$1"; shift
	[ -f "$cgroupfs/cgroup.stat" ] || error "cgroup unavailable"
	[ -d "$cgroup_master" ] || mkdir "$cgroup_master"
	[ -d "$cgroup_dir" ] || mkdir "$cgroup_dir"
	case "$oper" in
	is_running):
		[ "$(head -c 1 "$cgroup_dir/cgroup.procs")" ] && \
		 echo 1 || echo 0;;
	attach) echo "$$" > "$cgroup_dir/cgroup.procs";;
	kill) echo 1 > "$cgroup_dir/cgroup.kill";;
	cleanup) cgroup remove_flags; rmdir "$cgroup_dir";;
	ps) cat "$cgroup_dir/cgroup.procs";;
	mark) [ "$(cgroup is_marked "$1")" = 1 ] || mkdir "$cgroup_dir/_mark_$1";;
	unmark) [ "$(cgroup is_marked "$1")" = 0 ] || rmdir "$cgroup_dir/_mark_$1";;
	is_marked) [ -d "$cgroup_dir/_mark_$1" ] && echo 1 || echo 0;;
	remove_flags) cgroup mark _placeholder; rmdir "$cgroup_dir/_mark_"*;;
	kill_all):
		for i in "$cgroup_prefix"*
		do	echo 1 > "$i/cgroup.kill"
		done;;
	*) error "unknown cgroup operation '$oper'";;
	esac
}

cont()
{
need_config
	local oper="$1"; shift
	case "$oper" in
	run)	[ "$(cgroup is_running)" = 1 ] || ns drop
		mount_fs
		fs switch_root
		cgroup attach
		ns exec env -i TERM="$TERM" "$@";;
	kill)	cgroup kill
		cgroup cleanup
		ns drop;;
	*) error "unknown containter operation '$oper'";;
	esac
}
