#!/data/data/com.termux/files/usr/bin/zsh -eu
## not executable, just for syntax highlighting

PS4='[%D{%6.}] '

set -eu

[ "${ZSH_VERSION-}" ] || \
{
        echo "[Error] Zsh required"
        echo "PS: This script has specfied Zsh as its runtime,"
        echo "please execute this script directly as a program."
        exit 1
}

zmodload zsh/system
setopt nullglob

unset LD_PRELOAD

COMMON="$(realpath $0)"
DIR=${COMMON%/*}
script="$(realpath $1)"
progname=$script:t

T_ROOT=/data/data/com.termux/files
TMP_D=$T_ROOT/usr/tmp
CG_FS=/sys/fs/cgroup
CG_HOST=$CG_FS/_tcm
CONF_D=$DIR/config
NS_D=$DIR/ns
config_loaded=0
L_FD=
L_FILE=$DIR/COMMON
L_GET=0

container_mount()(:)

load_config()
{
	case $1 in
	*/*|*"'"*) error "invalid container name";;
	esac
	C_NAME=$1
	cgroup_dir=$CG_HOST/_$C_NAME
	local container_description="(no description)"
	unset container_root
	. $CONF_D/$C_NAME.conf
	C_ROOT=$container_root
	C_DESC=$container_description
	[[ -d $C_ROOT ]] || mkdir -o $C_ROOT
	config_loaded=1
}

need_config() # use brackets to correctly exit
{
	[[ $config_loaded = 1 ]] || error "no config loaded"
}

error() # don't use () because exit doesn't work in a subshell
{
	echo "$progname: $1" >&2; exit ${2-1}
}

countdown() ### ( time/s:, [msg], [finmsg] )
{
	local time=$1 msg=${2-} finmsg=${3-}
	while [[ $time -gt 0 ]]
	do	echo $msg$time
		sleep 1
		let --time
	done
	[[ -n $finmsg ]] || echo $finmsg
}

lock()
{
	local oper=$1
	case $oper in
	get)	[[ $L_GET = 0 ]] || return 0
		zsystem flock -t 0 -f L_FD $L_FILE || \
		{
			[[ $? = 2 ]] || error "failed to get lock"
			echo "lock is held by another process, waiting..."
		}
		zsystem flock -i 0.5 -f L_FD $L_FILE
		L_GET=1;;
	drop):	[[ $L_GET = 1 ]] || return 0
		zsystem flock -u $L_FD || error "cannot drop lock"
		L_GET=0;;
	esac
}

ns()
{
need_config
	local oper=$1 mntns=$NS_D/$C_NAME.mnt; shift
	case $oper in
	open)	[[ -d $NS_D ]] || mkdir $NS_D
		[[ -f $mntns ]] || touch $mntns
		[[ "$(stat -fc %T $mntns)" = nsfs ]] || \
		 unshare --mount=$mntns true;;
	drop)	while [[ "$(stat -fc %T $mntns)" = nsfs ]]
		do umount $mntns 2>/dev/null
		done
		fs remove_switched_root_flag;;
	run|exec):
		local prog=$1 exec=; shift
		ns open
		[[ $oper = run ]] || exec=exec
		$=exec nsenter -m$mntns -- $prog $@;;
	*) error "unknown ns operation '$oper'";;
	esac
}

fs()
{
need_config
	local oper=$1; shift
	case $oper in
	is_switched_root) cgroup is_marked switched_root;;
	remove_switched_root_flag) cgroup unmark switched_root;;
	switch_root):
		[[ "$(fs is_switched_root)" = 0 ]] || return 0
		cgroup mark switched_root;;
	bind)	local src=$1; dst=$2; shift 2
		[[ "$(fs is_switched_root)" = 0 ]] || return 0
		[[ -d $C_ROOT/$dst ]] || mkdir -p $C_ROOT/$dst
		ns run mount $@ -R $src $C_ROOT/$dst;;
	esac
}

macro()
{
need_config
	local oper=$1; shift
	case $oper in
	mount_base):
		## suid root
		fs bind $C_ROOT / -o suid,dev
		## linux runtime
		for i in /proc /sys /dev
		do fs bind $i $i
		done;;
	mount_android_runtime):
		for i in /apex/com.android.runtime /linkerconfig /system
		do fs bind $i $i
		done;;
	esac
}

mount_fs()
{
need_config
	macro mount_base
	container_mount
}

cgroup()
{
need_config
	local oper=$1; shift
	[[ -f $CG_FS/cgroup.stat ]] || error "cgroup unavailable"
	[[ -d $CG_HOST ]] || mkdir $CG_HOST
	[[ -d $cgroup_dir ]] || mkdir $cgroup_dir
	case $oper in
	is_running):
		[ "$(head -c 1 $cgroup_dir/cgroup.procs)" ] && \
		 echo 1 || echo 0;;
	attach) echo $$ > $cgroup_dir/cgroup.procs;;
	kill) echo 1 > $cgroup_dir/cgroup.kill;;
	cleanup) cgroup remove_flags; rmdir $cgroup_dir;;
	ps) cat $cgroup_dir/cgroup.procs;;
	mark) [[ -d $cgroup_dir/_mark_$1 ]] || mkdir $cgroup_dir/_mark_$1;;
	unmark) [[ ! -d $cgroup_dir/_mark_$1 ]] || rmdir $cgroup_dir/_mark_$1;;
	is_marked) [[ -d $cgroup_dir/_mark_$1 ]] && echo 1 || echo 0;;
	remove_flags) rmdir $cgroup_dir/_mark_*;;
	kill_all):
		for i in $CG_HOST/_*
		do	echo 1 > $i/cgroup.kill
		done;;
	*) error "unknown cgroup operation '$oper'";;
	esac
}

cont()
{
need_config
	local oper=$1; shift
	case $oper in
	run)	[[ "$(cgroup is_running)" = 1 ]] || ns drop
		mount_fs
		fs switch_root
		cgroup attach
		ns exec chroot $C_ROOT /bin/env -i TERM=$TERM $@;;
	kill)	cgroup kill
		cgroup cleanup
		ns drop;;
	*) error "unknown containter operation '$oper'";;
	esac
}

# end of defs

[[ "$(id -u)" = 0 ]] || error "need root privilege"

lock get
