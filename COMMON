#!/bin/sh ## not executable, just for syntax highlighting

unset LD_PRELOAD

script="$(realpath "$0")"
dir="$(dirname "$script")"
progname="$(basename "$0")"
realprog="$(basename "$script")"

termux_root="/data/data/com.termux/files"
tmpdir="$termux_root/usr/tmp"
cgroupfs="/sys/fs/cgroup"
cgroup_master="$cgroupfs/tcm"
cgroup_prefix="$cgroup_master/_"
config_dir="$dir/config"
ns_dir="$dir/ns"
config_loaded=0

container_mount()(:)

load_config()
{
	case "$1" in
	*/*) error "unexpected slash in container name";;
	esac
	cont_name="$1"
	cgroup_dir="$cgroup_prefix$cont_name"
	local container_description="(no description)"
	unset container_root
	. "$config_dir/$cont_name.conf"
	cont_root="$container_root"
	cont_desc="$container_description"
	[ -d "$cont_root" ] || mkdir -o "$cont_root"
	config_loaded=1
}

need_config() # use brackets to correctly exit
{
	[ "$config_loaded" = 1 ] || error "no config loaded"
}

error() # don't use () because exit doesn't work in a subshell
{
	echo "$progname: $1" >&2; exit "${2-1}"
}

require()
{
	notfound()
	{
		error "${1-"error: need $i, please check system environment"}"
	}
	for i in "$@"
	do	case "$1" in
		dir:*) [ -d "${i#dir:}" ] || notfound;;
		file:*) [ -f "${i#file:}" ] || notfound;;
		fsentry:*) [ -e "${i#fsentry:}" ] || notfound;;
		cmd:*) type "${i#cmd:}" >/dev/null 2>&1 || notfound;;
		*) notfound "unknown requirement: $i";;
		esac
	done
}

countdown() ### ( time/s:, [msg], [finmsg] )
{
	local time="$1" msg="${2-}" finmsg="${3-}"
	while [ "$time" -gt 0 ]
	do	echo "$msg$time"
		sleep 1
		time="$((time - 1))"
	done
	[ "$finmsg" = "" ] || echo "$finmsg"
}

[ "$(id -u)" = 0 ] || error "need root privilege"

require cmd:tput
[ "${COLUMNS-}" ] || COLUMNS="$(tput cols)"

unshare_exec()
{
need_config
	local prog="$1"; shift
	[ -d "$ns_dir" ] || mkdir "$ns_dir"
	[ -f "$ns_dir/$cont_name.mnt" ] || touch "$ns_dir/$cont_name.mnt"
	exec unshare --mount="$ns_dir/$cont_name.mnt" -- ${DEBUG-} "$prog" "$@"
}

add_bind()
{
need_config
	local src="$1"; dst="$2"; shift 2
	[ -d "$cont_root/$dst" ] || mkdir -p "$cont_root/$dst"
	mount "$@" -R "$src" "$cont_root/$dst"
}

mount_base()
{
need_config
	## suid root
	add_bind "$cont_root" "/" -o suid,dev
	## linux runtime
	for i in /proc /sys /dev
	do add_bind "$i" "$i"
	done
}

mount_android_runtime()
{
	for i in /apex/com.android.runtime /linkerconfig /system
	do add_bind "$i" "$i"
	done
}

mount_fs()
{
need_config
	mount_base
	container_mount
}

switch_root()
{
need_config
require cmd:busybox
	cd "$cont_root"
	busybox pivot_root "$cont_root" .
	umount -fl .
	cd /
}

echoret()
{
	local msg="$1" ret="${2-0}"
	echo "$msg"
	return "$ret"
}

cgroup()
{
need_config
	local oper="$1"
	[ -f "$cgroupfs/cgroup.stat" ] || error "cgroup unavailable"
	[ -d "$cgroup_master" ] || mkdir "$cgroup_master"
	[ -d "$cgroup_dir" ] || mkdir "$cgroup_dir"
	case "$oper" in
	is_running)	[ "$(head -c 1 "$cgroup_dir/cgroup.procs")" ] && \
			 echoret 1 || echoret 0;;
	attach) echo "$$" > "$cgroup_dir/cgroup.procs";;
	kill) echo 1 > "$cgroup_dir/cgroup.kill";;
	ps) cat "$cgroup_dir/cgroup.procs";;
	kill_all)	for i in "$cgroup_prefix"*
			do	echo 1 > "$i/cgroup.kill"
			done;;
	*) error "unknown cgroup operation $1";;
	esac
}

run_cont()
{
	[ "$(cgroup is_running)" = 1 ] || \
	{
		mount_fs
		switch_root
	}
	cgroup attach
	exec env -i TERM="$TERM" "$@"
}

kill_cont()
{
	cgroup kill
}
